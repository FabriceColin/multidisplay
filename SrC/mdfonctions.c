/*
**
** MULTI DISPLAY
*/
#include "defs.h"
#include "mdstrings.h"

/* External functions */
#include "mdprincipal.h"
#include "mddatatypes.h"
#include "mdreqtools.h"

extern struct Library *SysBase,*DOSBase;
struct Library *WorkbenchBase,*LocaleBase,*IconBase,*DataTypesBase,*IFFParseBase,*ReqToolsBase;

extern BOOL sync,show;                          /* Parameters */
extern STRPTR g_strDef;                         /* Default instruction */
struct LocaleInfo liLocale;

/* Verify sytem version */
BOOL SysVersionCheck(void)
{
   if( SysBase->lib_Version < 39 )
      return FALSE;
   return TRUE;
}

/* Open needed libraries */
BOOL OuvrirLibrairies(void)
{
   struct TagItem ptiLocaleItems[2];
   BOOL bResult=TRUE;

   /* Français est le langage par defaut , n'est ce pas ? */
   ptiLocaleItems[0].ti_Tag = OC_BuiltInLanguage;
   ptiLocaleItems[0].ti_Data = (ULONG)"français";
   ptiLocaleItems[1].ti_Tag = TAG_DONE;

   if( !(WorkbenchBase = OpenLibrary("workbench.library",39)) )
      bResult = FALSE;
   if( !(IconBase = OpenLibrary("icon.library",39)) )
      bResult = FALSE;
   if( (LocaleBase = OpenLibrary("locale.library",38)) )
   {
      liLocale.li_LocaleBase = (APTR)LocaleBase;
      liLocale.li_Catalog = OpenCatalogA(NULL,"md.catalog",ptiLocaleItems);
   }
   else bResult = FALSE;
   if( !(DataTypesBase = OpenLibrary("datatypes.library", 39)) )
      bResult = FALSE;
   if( !(IFFParseBase = OpenLibrary("iffparse.library", 39)) )
      bResult = FALSE;
   if( !(ReqToolsBase = OpenLibrary("reqtools.library",38)) )
      bResult = FALSE;
   return bResult;
}

/* Close all libraries and MultiDisplay catalog */
void FermerLibrairies(void)
{
   if( ReqToolsBase )
   {
      CloseLibrary(ReqToolsBase);
      ReqToolsBase = NULL;
   }
   if( ReqToolsBase )
   {
      CloseLibrary(IFFParseBase);
      ReqToolsBase = NULL;
   }
   if( liLocale.li_Catalog )
   {
      CloseCatalog(liLocale.li_Catalog);
      liLocale.li_Catalog = NULL;
   }
   if( LocaleBase )
   {
      CloseLibrary(LocaleBase);
      LocaleBase = NULL;
   }
   if( ReqToolsBase )
   {
      CloseLibrary(DataTypesBase);
      DataTypesBase = NULL;
   }
   if( IconBase )
   {
      CloseLibrary(IconBase);
      IconBase = NULL;
   }
   if( WorkbenchBase )
   {
      CloseLibrary(WorkbenchBase);
      WorkbenchBase = NULL;
   }
}

/* This function is usually generated by 'CatComp bogus.cd CFILE bogus_strings.h' */
STRPTR GetString(struct LocaleInfo *li, LONG stringNum)
{
   LONG   *l;
   UWORD  *w;
   STRPTR  builtIn;

   l = (LONG *)CatCompBlock;

   while (*l != stringNum)
   {
      w = (UWORD *)((ULONG)l + 4);
      l = (LONG *)((ULONG)l + (ULONG)*w + 6);
   }
   builtIn = (STRPTR)((ULONG)l + 6);

#undef LocaleBase
#define LocaleBase li->li_LocaleBase
   if( LocaleBase )
      return GetCatalogStr(li->li_Catalog,stringNum,builtIn);
#undef LocaleBase
   return builtIn;
}

void *MemoryAlloc(ULONG ulSize,BOOL bClear)
{
   ULONG ulFlags = MEMF_PUBLIC|MEMF_REVERSE;
   void *pMem;

   if( bClear == TRUE )
      ulFlags = ulFlags | MEMF_CLEAR;
   pMem = AllocVec(ulSize,ulFlags);
   if( pMem == NULL )
   {
#ifdef DEBUG_INFO
      printf("Couldn't allocate %ld bytes\n",ulSize);
#endif
      exit(RETURN_ERROR);
   }
#ifdef DEBUG_INFO
   printf("%ld bytes allocated at %p\n",ulSize,pMem);
#endif
   return pMem;
}

/* Wrapper for System() */
BOOL Commande(STRPTR strExe,STRPTR strArg)
{
   struct TagItem ptiTags[5];
   STRPTR strBuff;
   BOOL bResult=TRUE;
   int i=2;

   strBuff = (STRPTR)MemoryAlloc(MAX_BUFFER,TRUE);

   /* Does the argument exist ? */
   if( strArg != NULL )
   {
      sprintf(strBuff,"%s \"%s\"\0",strExe,strArg);
   }
#ifdef DEBUG_INFO
   printf("Call : %s\n",strBuff);
#endif

   /* Tags */
   ptiTags[0].ti_Tag = SYS_Input;
   ptiTags[0].ti_Data = NULL;
   ptiTags[1].ti_Tag = SYS_Output;
   ptiTags[1].ti_Data = NULL;
   if( sync == FALSE )
   {
      ptiTags[2].ti_Tag = SYS_Asynch;
      ptiTags[2].ti_Data = TRUE;
      i = 3;
   }
   ptiTags[i].ti_Tag = SYS_UserShell;
   ptiTags[i].ti_Data = TRUE;
   ptiTags[i+1].ti_Tag = TAG_DONE;
   /* Run the program */
   if( SystemTagList(strBuff, ptiTags) == SYSTEMFAIL )
      bResult = FALSE;

   FreeVec(strBuff);

   return bResult;
}

/* Compare configuration types with file DataType */
BOOL ComparaisonID(STRPTR strBuff,STRPTR id)
{
   BOOL bStop=FALSE;

   if( (strBuff != NULL) && (id != NULL) && ( stricmp(strBuff,id) == 0 ) )
   {
      bStop = TRUE;
#ifdef DEBUG_INFO
      printf("ID : %s\n",strBuff);
#endif
   }
   return bStop;
}

/* Compare configuration types with file name */
BOOL ComparaisonNom(STRPTR strBuff,STRPTR strArg)
{
   BOOL bStop=FALSE;
   STRPTR strArg2,strBuff2;
   int i;

   strArg2 = (STRPTR)MemoryAlloc(MAX_BUFFER,TRUE);
   strBuff2 = (STRPTR)MemoryAlloc(MAX_BUFFER,TRUE);

   for(i=0;i<strlen( strArg );i++)
      strArg2[i] = tolower(strArg[i]);
   strArg2[i] = '\0';
   for(i=0;i<strlen( strBuff );i++)
      strBuff2[i] = tolower(strBuff[i+1]);

   if( strstr(strArg2,strBuff2) )
   {
      bStop = TRUE;
#ifdef DEBUG_INFO
      printf("Name : %s\n",strBuff2);
#endif
   }
   FreeVec(strArg2);
   FreeVec(strBuff2);

   return bStop;
}

/* Search the argument type by comparing with configuration defined types
   Return FALSE if MultiDisplay has to stop */
BOOL Recherche(STRPTR strArg,ULONG ulMode)
{
   BOOL   bResult=TRUE, bReturn;
   STRPTR strBuff,strGroup,strBaseName;

   strBuff = (STRPTR)MemoryAlloc(MAX_BUFFER,TRUE);
   strGroup = (STRPTR)MemoryAlloc(MAX_BUFFER,TRUE);
   strBaseName = (STRPTR)MemoryAlloc(MAX_BUFFER,TRUE);

   bResult = ExamenDT(strArg,&strGroup,&strBaseName);
   /* Show the file DataType ? */
   if( show == TRUE )
   {
      /* Unknown DataType */
      if( bResult == FALSE )
      {
#ifdef DEBUG_INFO
         printf("Type de données inconnu ...\n");
#endif
         sprintf(strBuff,GetString(&liLocale,MSG_UNKNOWNID),strArg);
      }
      else
         sprintf(strBuff,GetString(&liLocale,MSG_SHOWID),strArg,strGroup,strBaseName);

      switch( RTInfo(strBuff,ulMode) )
      {
         case REPLY_NEXT_INFO:                  /* Don't examine this file */
            bReturn = TRUE;
            bResult = TRUE;
            break;
         case REPLY_STOP_INFO:                  /* Stop */
            bReturn = TRUE;
            bResult = FALSE;
            break;
         default:
         case REPLY_OK_INFO:                    /* OK : resume */
            bReturn = FALSE;
            break;
      }
   }

   /* Free this now */
   FreeVec(strBuff);
   strBuff = NULL;
   /* Quit ? */
   if( bReturn == TRUE )
   {
      FreeVec(strGroup);
      FreeVec(strBaseName);
      return bResult;
   }

#ifdef DEBUG_INFO
    printf("Searching for file type...\n");
#endif
   if( bResult == FALSE )
      strBuff = TrouverConfig(strArg,NULL);
   else
      strBuff = TrouverConfig(strArg,strBaseName);

   if( strBuff == NULL )
      bResult = Commande(g_strDef,strArg);
   else
      bResult = Commande(strBuff,strArg);

   FreeVec(strGroup);
   FreeVec(strBaseName);

   return TRUE;
}
